{"version":3,"sources":["@@\\dist\\lib\\index.js","@@\\dist\\lib\\bokeh_extensions\\index.js","@@\\dist\\lib\\bokeh_extensions\\web_component.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    const AwesomePanelExtensions = tslib_1.__importStar(require(\"515b1a12fc\") /* ./bokeh_extensions/ */);\r\n    exports.AwesomePanelExtensions = AwesomePanelExtensions;\r\n    const base_1 = require(\"@bokehjs/base\");\r\n    base_1.register_models(AwesomePanelExtensions);\r\n}\r\n","/* bokeh_extensions\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var web_component_1 = require(\"5c604c9068\") /* ./web_component */;\r\n    exports.WebComponent = web_component_1.WebComponent;\r\n}\r\n","/* bokeh_extensions\\web_component.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(\"tslib\");\r\n    const dom_1 = require(\"@bokehjs/core/dom\");\r\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\r\n    const html_box_1 = require(\"@bokehjs/models/layouts/html_box\");\r\n    const inputs_1 = require(\"@bokehjs/styles/widgets/inputs\");\r\n    function htmlDecode(input) {\r\n        var doc = new DOMParser().parseFromString(input, \"text/html\");\r\n        return doc.documentElement.textContent;\r\n    }\r\n    class WebComponentView extends html_box_1.HTMLBoxView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.name.change, () => this.handleNameChange());\r\n            this.connect(this.model.properties.innerHTML.change, () => this.render());\r\n            this.connect(this.model.properties.attributesLastChange.change, () => this.handleAttributesLastChangeChange());\r\n            this.connect(this.model.properties.propertiesLastChange.change, () => this.handlePropertiesLastChangeChange());\r\n            this.connect(this.model.properties.columnDataSource.change, () => this.handleColumnDataSourceChange());\r\n        }\r\n        handleNameChange() {\r\n            if (this.label_el)\r\n                this.label_el.textContent = this.model.name;\r\n        }\r\n        render() {\r\n            super.render();\r\n            if (this.el.innerHTML !== this.model.innerHTML)\r\n                this.createOrUpdateWebComponentElement();\r\n        }\r\n        after_layout() {\r\n            if (\"after_layout\" in this.webComponentElement)\r\n                this.webComponentElement.after_layout();\r\n        }\r\n        createOrUpdateWebComponentElement() {\r\n            if (this.webComponentElement)\r\n                this.webComponentElement.onchange = null;\r\n            // @Philippfr: How do we make sure the component is automatically sized according to the\r\n            // parameters of the WebComponent like width, height, sizing_mode etc?\r\n            // Should we set height and width to 100% or similar?\r\n            // For now I've set min_height as a part of .py __init__ for some of the Wired components?\r\n            const title = this.model.name;\r\n            if (this.model.componentType === \"inputgroup\" && title) {\r\n                this.group_el = dom_1.div({ class: inputs_1.bk_input_group }, this.label_el);\r\n                this.group_el.innerHTML = htmlDecode(this.model.innerHTML);\r\n                this.webComponentElement = this.group_el.firstElementChild;\r\n                this.label_el = dom_1.label({ style: { display: title.length == 0 ? \"none\" : \"\" } }, title);\r\n                this.group_el.insertBefore(this.label_el, this.webComponentElement);\r\n                this.el.appendChild(this.group_el);\r\n            }\r\n            else {\r\n                this.el.innerHTML = htmlDecode(this.model.innerHTML);\r\n                this.webComponentElement = this.el.firstElementChild;\r\n            }\r\n            this.activate_scripts(this.webComponentElement.parentNode);\r\n            // Initialize properties\r\n            this.initPropertyValues();\r\n            this.handlePropertiesLastChangeChange();\r\n            this.handleColumnDataSourceChange();\r\n            // Subscribe to events\r\n            this.webComponentElement.onchange = (ev) => this.handlePropertiesChange(ev);\r\n            this.addEventListeners();\r\n            this.addAttributesMutationObserver();\r\n        }\r\n        addAttributesMutationObserver() {\r\n            if (!this.model.attributesToWatch)\r\n                return;\r\n            let options = {\r\n                childList: false,\r\n                attributes: true,\r\n                characterData: false,\r\n                subtree: false,\r\n                attributeFilter: Object.keys(this.model.attributesToWatch),\r\n                attributeOldValue: false,\r\n                characterDataOldValue: false\r\n            };\r\n            const handleAttributesChange = (_) => {\r\n                let attributesLastChange = new Object();\r\n                for (let attribute in this.model.attributesToWatch) {\r\n                    const value = this.webComponentElement.getAttribute(attribute);\r\n                    attributesLastChange[attribute] = value;\r\n                }\r\n                if (this.model.attributesLastChange !== attributesLastChange)\r\n                    this.model.attributesLastChange = attributesLastChange;\r\n            };\r\n            let observer = new MutationObserver(handleAttributesChange);\r\n            observer.observe(this.webComponentElement, options);\r\n        }\r\n        addEventListeners() {\r\n            this.eventsCount = {};\r\n            for (let event in this.model.eventsToWatch) {\r\n                this.eventsCount[event] = 0;\r\n                this.webComponentElement.addEventListener(event, (ev) => this.eventHandler(ev), false);\r\n            }\r\n        }\r\n        transform_cds_to_records(cds) {\r\n            const data = [];\r\n            const columns = cds.columns();\r\n            const cdsLength = cds.get_length();\r\n            if (columns.length === 0 || cdsLength === null) {\r\n                return [];\r\n            }\r\n            for (let i = 0; i < cdsLength; i++) {\r\n                const item = {};\r\n                for (const column of columns) {\r\n                    let array = cds.get_array(column);\r\n                    const shape = array[0].shape == null ? null : array[0].shape;\r\n                    if ((shape != null) && (shape.length > 1) && (typeof shape[0] == \"number\"))\r\n                        item[column] = array.slice(i * shape[1], i * shape[1] + shape[1]);\r\n                    else\r\n                        item[column] = array[i];\r\n                }\r\n                data.push(item);\r\n            }\r\n            return data;\r\n        }\r\n        // https://stackoverflow.com/questions/5999998/check-if-a-variable-is-of-function-type\r\n        isFunction(functionToCheck) {\r\n            if (functionToCheck) {\r\n                const stringName = {}.toString.call(functionToCheck);\r\n                return stringName === '[object Function]' || stringName === '[object AsyncFunction]';\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Handles changes to `this.model.columnDataSource`\r\n         * by\r\n         * updating the data source of `this.webComponentElement`\r\n         * using the function or property specifed in `this.model.columnDataSourceLoadFunction`\r\n         */\r\n        handleColumnDataSourceChange() {\r\n            // @Philippfr: Right now we just reload all the data\r\n            // For example Perspective has an `update` function to append data\r\n            // Is this something we could/ should support?\r\n            if (this.model.columnDataSource) {\r\n                let data; // list\r\n                const columnDataSourceOrient = this.model.columnDataSourceOrient;\r\n                if (columnDataSourceOrient === \"records\")\r\n                    data = this.transform_cds_to_records(this.model.columnDataSource);\r\n                else\r\n                    data = this.model.columnDataSource.data; // @ts-ignore\r\n                const loadFunctionName = this.model.columnDataSourceLoadFunction.toString();\r\n                const loadFunction = this.webComponentElement[loadFunctionName];\r\n                if (this.isFunction(loadFunction))\r\n                    this.webComponentElement[loadFunctionName](data);\r\n                else\r\n                    this.webComponentElement[loadFunctionName] = data;\r\n            }\r\n            // Todo: handle situation where this.model.columnDataSource is null\r\n        }\r\n        activate_scripts(el) {\r\n            Array.from(el.querySelectorAll(\"script\")).forEach((oldScript) => {\r\n                const newScript = document.createElement(\"script\");\r\n                Array.from(oldScript.attributes)\r\n                    .forEach(attr => newScript.setAttribute(attr.name, attr.value));\r\n                newScript.appendChild(document.createTextNode(oldScript.innerHTML));\r\n                if (oldScript.parentNode)\r\n                    oldScript.parentNode.replaceChild(newScript, oldScript);\r\n            });\r\n        }\r\n        // See https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key\r\n        /**\r\n         * Example:\r\n         *\r\n         * `get_nested_property(element, \"textInput.value\")` returns `element.textInput.value`\r\n         *\r\n         * @param element\r\n         * @param property_\r\n         */\r\n        get_nested_property(element, property_) {\r\n            property_ = property_.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\r\n            property_ = property_.replace(/^\\./, ''); // strip a leading dot\r\n            let a = property_.split('.');\r\n            for (let i = 0, n = a.length; i < n; ++i) {\r\n                let k = a[i];\r\n                if (k in element)\r\n                    element = element[k];\r\n                else\r\n                    return \"\";\r\n            }\r\n            return element;\r\n        }\r\n        set_nested_property(element, property_, value) {\r\n            // @Phillipfr: I need your help to understand and solve this\r\n            // hack: Setting the value of the WIRED-SLIDER before its ready\r\n            // will destroy the setter.\r\n            // I don't yet understand this.\r\n            // if ([\"WIRED-SLIDER\"].indexOf(element.tagName)>=0){\r\n            //   const setter = element.__lookupSetter__(property_);\r\n            //   if (!setter){return}\r\n            // }\r\n            const pList = property_.split('.');\r\n            if (pList.length === 1)\r\n                element[property_] = value;\r\n            else {\r\n                const len = pList.length;\r\n                for (let i = 0; i < len - 1; i++) {\r\n                    const elem = pList[i];\r\n                    if (!element[elem])\r\n                        element[elem] = {};\r\n                    element = element[elem];\r\n                }\r\n                element[pList[len - 1]] = value;\r\n            }\r\n        }\r\n        /**\r\n         * Handles events from `eventsToWatch` by\r\n         *\r\n         * - Incrementing the count of the event\r\n         * - Checking if any properties have changed\r\n         *\r\n         * @param ev The Event Fired\r\n         */\r\n        eventHandler(ev) {\r\n            let event = ev.type;\r\n            this.eventsCount[event] += 1;\r\n            let eventsCountLastChanged = {};\r\n            eventsCountLastChanged[event] = this.eventsCount[event];\r\n            this.model.eventsCountLastChange = eventsCountLastChanged;\r\n            this.checkIfPropertiesChanged();\r\n        }\r\n        /** Checks if any properties have changed. In case this is communicated to the server.\r\n         *\r\n         * For example the Wired `DropDown` does not run the `onchange` event handler when the selection changes.\r\n         * Insted the `select` event is fired. Thus we can subscribe to this event and manually check for property changes.\r\n         */\r\n        checkIfPropertiesChanged() {\r\n            const propertiesChange = {};\r\n            for (const property in this.model.propertiesToWatch) {\r\n                const oldValue = this.propertyValues[property];\r\n                const newValue = this.get_nested_property(this.webComponentElement, property);\r\n                if (oldValue != newValue) {\r\n                    propertiesChange[property] = newValue;\r\n                    this.propertyValues[property] = newValue;\r\n                }\r\n            }\r\n            if (Object.keys(propertiesChange).length)\r\n                this.model.propertiesLastChange = propertiesChange;\r\n        }\r\n        /** Handles the `WebComponentElement` `(on)change` event\r\n         *\r\n         * Communicates any changed properties in `propertiesToWatch` to the server\r\n         * by updating `this.model.propertiesLastChange`.\r\n         * @param ev\r\n         */\r\n        handlePropertiesChange(ev) {\r\n            const properties_change = new Object();\r\n            for (const property in this.model.propertiesToWatch) {\r\n                if (ev.detail && property in ev.detail) {\r\n                    properties_change[property] = ev.detail[property];\r\n                    this.propertyValues[property] = ev.detail[property];\r\n                }\r\n                else if (ev.target && property in ev.target) {\r\n                    properties_change[property] = ev.target[property];\r\n                    this.propertyValues[property] = ev.target[property];\r\n                }\r\n            }\r\n            if (Object.keys(properties_change).length)\r\n                this.model.propertiesLastChange = properties_change;\r\n        }\r\n        initPropertyValues() {\r\n            this.propertyValues = new Object();\r\n            if (!this.webComponentElement) {\r\n                return;\r\n            }\r\n            for (let property in this.model.propertiesToWatch) {\r\n                let old_value = this.propertyValues[property];\r\n                let new_value = this.get_nested_property(this.webComponentElement, property);\r\n                if (new_value !== old_value) {\r\n                    this.propertyValues[property] = new_value;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Handles changes to `this.model.attributesLastChange`\r\n         * by\r\n         * updating the attributes of `this.webComponentElement` accordingly\r\n         */\r\n        handleAttributesLastChangeChange() {\r\n            if (!this.webComponentElement)\r\n                return;\r\n            let attributesLastChange = this.model.attributesLastChange;\r\n            for (let attribute in this.model.attributesLastChange) {\r\n                if (attribute in this.model.attributesToWatch) {\r\n                    let old_value = this.webComponentElement.getAttribute(attribute);\r\n                    let new_value = attributesLastChange[attribute];\r\n                    if (old_value !== new_value) {\r\n                        if (new_value === null)\r\n                            this.webComponentElement.removeAttribute(attribute);\r\n                        else\r\n                            this.webComponentElement.setAttribute(attribute, new_value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n        * Handles changes to `this.model.propertiesLastChange`\r\n        * by\r\n        * updating the properties of `this.webComponentElement` accordingly\r\n        */\r\n        handlePropertiesLastChangeChange() {\r\n            if (!this.webComponentElement) {\r\n                return;\r\n            }\r\n            let propertiesLastChange = this.model.propertiesLastChange;\r\n            for (let property in this.model.propertiesLastChange) {\r\n                if (property in this.model.propertiesToWatch) {\r\n                    let value = propertiesLastChange[property];\r\n                    this.set_nested_property(this.webComponentElement, property, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.WebComponentView = WebComponentView;\r\n    WebComponentView.__name__ = \"WebComponentView\";\r\n    class WebComponent extends html_box_1.HTMLBox {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_WebComponent() {\r\n            this.prototype.default_view = WebComponentView;\r\n            this.define({\r\n                // @Philipfr: How do I make property types more specific\r\n                componentType: [p.String, 'htmlbox'],\r\n                innerHTML: [p.String, ''],\r\n                attributesToWatch: [p.Any],\r\n                attributesLastChange: [p.Any],\r\n                propertiesToWatch: [p.Any],\r\n                propertiesLastChange: [p.Any],\r\n                eventsToWatch: [p.Any],\r\n                eventsCountLastChange: [p.Any],\r\n                columnDataSource: [p.Any],\r\n                columnDataSourceOrient: [p.Any],\r\n                columnDataSourceLoadFunction: [p.Any],\r\n            });\r\n        }\r\n    }\r\n    exports.WebComponent = WebComponent;\r\n    WebComponent.__name__ = \"WebComponent\";\r\n    WebComponent.__module__ = \"awesome_panel_extensions.bokeh_extensions.web_component\";\r\n    WebComponent.init_WebComponent();\r\n}\r\n"]}