# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _base
else:
    import _base

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def to_hex(bytes: 'std::string const &') -> "std::string":
    r"""to_hex(std::string const & bytes) -> std::string"""
    return _base.to_hex(bytes)

def to_bytes(hex: 'std::string const &') -> "std::string":
    r"""to_bytes(std::string const & hex) -> std::string"""
    return _base.to_bytes(hex)
import tick.array.build.array

def standard_normal_cdf(x: 'double') -> "double":
    r"""standard_normal_cdf(double x) -> double"""
    return _base.standard_normal_cdf(x)

def standard_normal_inv_cdf(*args) -> "void":
    r"""
    standard_normal_inv_cdf(double const q) -> double
    standard_normal_inv_cdf(ArrayDouble & q, ArrayDouble & out)
    """
    return _base.standard_normal_inv_cdf(*args)
class TimeFunction(object):
    r"""Proxy of C++ TimeFunction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    InterMode_InterLinear = _base.TimeFunction_InterMode_InterLinear
    
    InterMode_InterConstRight = _base.TimeFunction_InterMode_InterConstRight
    
    InterMode_InterConstLeft = _base.TimeFunction_InterMode_InterConstLeft
    
    BorderType_Border0 = _base.TimeFunction_BorderType_Border0
    
    BorderType_BorderConstant = _base.TimeFunction_BorderType_BorderConstant
    
    BorderType_BorderContinue = _base.TimeFunction_BorderType_BorderContinue
    
    BorderType_Cyclic = _base.TimeFunction_BorderType_Cyclic
    

    def __init__(self, *args):
        r"""
        __init__(TimeFunction self, ArrayDouble const & T, ArrayDouble const & Y, TimeFunction::BorderType type, TimeFunction::InterMode mode, double dt, double border_value) -> TimeFunction
        __init__(TimeFunction self, double y=0.0) -> TimeFunction
        """
        _base.TimeFunction_swiginit(self, _base.new_TimeFunction(*args))

    def value(self, *args) -> "SArrayDoublePtr":
        r"""
        value(TimeFunction self, double t) -> double
        value(TimeFunction self, ArrayDouble & array) -> SArrayDoublePtr
        """
        return _base.TimeFunction_value(self, *args)

    def future_bound(self, *args) -> "SArrayDoublePtr":
        r"""
        future_bound(TimeFunction self, double t) -> double
        future_bound(TimeFunction self, ArrayDouble & array) -> SArrayDoublePtr
        """
        return _base.TimeFunction_future_bound(self, *args)

    def max_error(self, t: 'double') -> "double":
        r"""max_error(TimeFunction self, double t) -> double"""
        return _base.TimeFunction_max_error(self, t)

    def compute_future_max(self) -> "void":
        r"""compute_future_max(TimeFunction self)"""
        return _base.TimeFunction_compute_future_max(self)

    def get_norm(self) -> "double":
        r"""get_norm(TimeFunction self) -> double"""
        return _base.TimeFunction_get_norm(self)

    def get_inter_mode(self) -> "TimeFunction::InterMode":
        r"""get_inter_mode(TimeFunction self) -> TimeFunction::InterMode"""
        return _base.TimeFunction_get_inter_mode(self)

    def get_border_type(self) -> "TimeFunction::BorderType":
        r"""get_border_type(TimeFunction self) -> TimeFunction::BorderType"""
        return _base.TimeFunction_get_border_type(self)

    def get_border_value(self) -> "double":
        r"""get_border_value(TimeFunction self) -> double"""
        return _base.TimeFunction_get_border_value(self)

    def get_sampled_y(self) -> "SArrayDoublePtr":
        r"""get_sampled_y(TimeFunction self) -> SArrayDoublePtr"""
        return _base.TimeFunction_get_sampled_y(self)

    def get_future_max(self) -> "SArrayDoublePtr":
        r"""get_future_max(TimeFunction self) -> SArrayDoublePtr"""
        return _base.TimeFunction_get_future_max(self)

    def get_dt(self) -> "double":
        r"""get_dt(TimeFunction self) -> double"""
        return _base.TimeFunction_get_dt(self)

    def __getstate__(self): return TimeFunctionSerialize(self)
    def __setstate__(self, s):
        self.__init__(0.0)
        return TimeFunctionDeserialize(self, s)

    __swig_destroy__ = _base.delete_TimeFunction

# Register TimeFunction in _base:
_base.TimeFunction_swigregister(TimeFunction)
cvar = _base.cvar
TimeFunction.DEFAULT_INTER = _base.cvar.TimeFunction_DEFAULT_INTER
TimeFunction.DEFAULT_BORDER = _base.cvar.TimeFunction_DEFAULT_BORDER


def TimeFunctionDeserialize(ptr: 'TimeFunction', hex: 'std::string const &') -> "void":
    r"""TimeFunctionDeserialize(TimeFunction ptr, std::string const & hex)"""
    return _base.TimeFunctionDeserialize(ptr, hex)

def TimeFunctionSerialize(ptr: 'TimeFunction') -> "std::string":
    r"""TimeFunctionSerialize(TimeFunction ptr) -> std::string"""
    return _base.TimeFunctionSerialize(ptr)
class A0(object):
    r"""Proxy of C++ A0 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def get_cpp_int(self) -> "int":
        r"""get_cpp_int(A0 self) -> int"""
        return _base.A0_get_cpp_int(self)

    def set_cpp_int(self, cpp_int: 'int') -> "void":
        r"""set_cpp_int(A0 self, int cpp_int)"""
        return _base.A0_set_cpp_int(self, cpp_int)

    def __init__(self):
        r"""__init__(A0 self) -> A0"""
        _base.A0_swiginit(self, _base.new_A0())
    __swig_destroy__ = _base.delete_A0

# Register A0 in _base:
_base.A0_swigregister(A0)


def throw_out_of_range() -> "void":
    r"""throw_out_of_range()"""
    return _base.throw_out_of_range()

def throw_system_error() -> "void":
    r"""throw_system_error()"""
    return _base.throw_system_error()

def throw_invalid_argument() -> "void":
    r"""throw_invalid_argument()"""
    return _base.throw_invalid_argument()

def throw_domain_error() -> "void":
    r"""throw_domain_error()"""
    return _base.throw_domain_error()

def throw_runtime_error() -> "void":
    r"""throw_runtime_error()"""
    return _base.throw_runtime_error()

def throw_string() -> "void":
    r"""throw_string()"""
    return _base.throw_string()


