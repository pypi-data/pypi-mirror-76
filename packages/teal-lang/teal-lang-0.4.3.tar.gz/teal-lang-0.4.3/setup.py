# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['teal_lang',
 'teal_lang.cli',
 'teal_lang.cloud',
 'teal_lang.controllers',
 'teal_lang.executors',
 'teal_lang.machine',
 'teal_lang.run',
 'teal_lang.teal_compiler',
 'teal_lang.teal_parser']

package_data = \
{'': ['*'], 'teal_lang': ['dist_data/teal.toml']}

install_requires = \
['PyInquirer>=1.0.3,<2.0.0',
 'boto3',
 'botocore',
 'coloredlogs>=14.0,<15.0',
 'colorful>=0.5.4,<0.6.0',
 'deterministic_zip>=0.1,<0.2',
 'docopt',
 'gql>=2.0.0,<3.0.0',
 'graphviz>=0.13.2,<0.14.0',
 'parsy>=1.3.0,<2.0.0',
 'pydot>=1.4.1,<2.0.0',
 'pynamodb',
 'pyyaml>=5.3.1,<6.0.0',
 'schema>=0.7.2,<0.8.0',
 'sly>=0.4,<0.5',
 'texttable>=1.6.2,<2.0.0',
 'toml>=0.10.1,<0.11.0',
 'yaspin>=0.17.0,<0.18.0']

entry_points = \
{'console_scripts': ['teal = teal_lang.cli.main:main']}

setup_kwargs = {
    'name': 'teal-lang',
    'version': '0.4.3',
    'description': 'The Teal Programming Language',
    'long_description': '![Teal](doc/teal.png)\n\n---\n\n![Tests](https://github.com/condense9/teal-lang/workflows/Build/badge.svg?branch=master) [![PyPI](https://badge.fury.io/py/teal-lang.svg)](https://pypi.org/project/teal-lang) [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black) [![Python 3.8](https://img.shields.io/badge/python-3.8-blue.svg)](https://www.python.org/downloads/release/python-380)\n\n**The Teal Programming Language**\n\nTeal hides the complexity of AWS Lambda + SQS, so you can build serverless data\nworkflows without managing infrastructure.\n\nDescribe your workflows in a *real programming language* with first-class\nfunctions, concurrency, and native Python inter-op. Test end-to-end locally,\nthen deploy to serverless AWS infrastructure in under 60s and start workflows\nfrom anything that can invoke Lambda.\n\nLike AWS Step Functions but cheaper and much nicer to use (overheads: a little\nLambda runtime, and a DynamoDB for Teal state).\n\nLike Serverless Framework, but handles runtime glue logic in addition to\ndeployment.\n\n*Status*: Teal works well for small workflows: 5-10 Lambda invocations. Larger\nworkflows may cause problems, and there is a known issue caused by DynamoDB\nrestrictions ([#12](https://github.com/condense9/teal-lang/issues/12)).\n\n<!-- As presented at PyCon Africa 2020. (Watch the presentation, or follow along with the examples). -->\n\n<!-- Watch an introduction video. -->\n\n[Get started in 2 minutes](#up-and-running-in-2-minutes).\n\n[Read the documentation](https://teal-book.condense9.com).\n\n[PyCon Africa 2020 Demos!](https://github.com/condense9/teal-demos).\n\n\n## Contributing\n\nTeal is growing rapidly, and contributions are [warmly welcomed](CONTRIBUTING.md).\n\n\n## Is Teal for me?\n\nTeal *is* for you if:\n- You use Python for processing data, or writing business process workflows.\n- You want an alternative to AWS Step Functions.\n- You don\'t want to to deploy and manage a task platform (Airflow, Celery, etc).\n\n**Data in**: You can invoke Teal like any Lambda function (AWS cli, S3 trigger,\nAPI gateway, etc).\n\n**Data out**: Use the Python libraries you already have for database access.\nTeal just connects them together.\n\n**Development**: Teal runs locally, so you can thoroughly test Teal programs\nbefore deployment (using minio and localstack for any additional infrastructure\nthat your code uses.\n\n**Operating**: Teal enables contextual cross-thread logging and stacktraces out\nof the box, since the entire application is described in one place.\n\n[Teal Cloud](https://condense9.com) (coming soon) will make this even easier,\nwith a graphical console, one-click rollbacks of entire serverless applications,\nand more. Sign up to the mailing list to hear about this first:\n[https://www.condense9.com/](https://www.condense9.com/).\n\n\n| Teal is like...                     | But...                                                                                                        |\n|-------------------------------------|---------------------------------------------------------------------------------------------------------------|\n| AWS Step Functions                  | Teal programs aren\'t bound to AWS and don\'t use Step Functions under the hood (just plain Lambda + DynamoDB). |\n| Orchestrators (Apache Airflow, etc) | You don\'t have to manage infrastructure, or think in terms of DAGs, and you can test everything locally.      |\n| Task runners (Celery, etc)          | You don\'t have to manage infrastructure.                                                                      |\n| Azure Durable Functions             | While powerful, Durable Functions (subjectively) feel complex - their behaviour isn\'t always obvious.         |\n\n\n[Read more...](https://teal-book.condense9.com/why.html)\n\n\n## Why should I learn a new language?\n\nBecause it\'ll give you a new way to *think* about cloud software.\n\nTeal is not a Python replacement. It has one specific goal: eliminate the need\nto *implement* infrastructure.\n\nWriting your own infrastructure is like writing assembly code - only do it if\nyou really have extreme or unusual requirements. Otherwise, use a high-level\nlanguage (Teal!) that hides the complexity and compiles to "soft\ninfrastructure".\n\n\n## Up and running in 2 minutes\n\nAll you need:\n- An AWS account, and [AWS CLI](https://github.com/aws/aws-cli#getting-started)\n  configured.\n- A Python 3.8 virtual environment\n\nTeal is built with Python, and distributed as a Python package. To install it,\nrun:\n\n```shell\n$ pip install teal-lang\n```\n\nThis gives you the `teal` executable. Try `teal -h`.\n\nCopy the following snippet into a file called `service.tl`:\n\n```\n// service.tl\n\nfn main() {\n  print("Hello World!");\n}\n```\n\nRun it (`-f main` is optional, and `main` is the default):\n\n```shell\n~/new_project $> teal service.tl -f main\n```\n\nInitialise the project (required for deployment):\n\n```shell\n~/new_project $> teal init\n```\n\nAnd deploy the service to your AWS account (requires AWS credentials and\n`AWS_DEFAULT_REGION` to be defined):\n\n```shell\n~/new_project $> teal deploy\n```\n\nFinally, invoke it in AWS (`-f main` is optional, as before):\n\n```shell\n~/new_project $> teal invoke -f main\n```\n\nThat\'s it! You now have a Teal instance configured in your AWS account, built on\nthe AWS serverless platform (S3 + Lambda + DynamoDB). [More info...](https://teal-book.condense9.com/dev/aws.html)\n\nExplore a more complex example: [Fractals](examples/fractals).\n\n[Create an issue](https://github.com/condense9/teal-lang/issues) if none of this\nmakes sense, or you\'d like help getting started.\n\nRead more...\n- [about the language](https://teal-book.condense9.com/language/index.html)\n- [about the development process](https://teal-book.condense9.com/development/index.html)\n- [about configuring Teal](https://teal-book.condense9.com/configuration.html)\n\n\n\n\n## Things Teal can do\n\nWhen running in AWS, Teal threads run in separate lambda invocations.\n\n### Concurrency & Synchronisation\n\nThis is useful when a set computations are related, and must be kept together.\n\n```javascript\n/**\n * Return f(x) + g(x), computing f(x) and g(x) in parallel in two separate\n * threads (Lambda invocations in AWS).\n */\nfn compute(x) {\n  a = async f(x);     // Start computing f(x) in a new thread\n  b = async g(x);     // Likewise with g(x)\n  await a + await b;  // Stop this thread, and resume when {a, b} are ready\n}\n```\n\n*Traditional approach*: Manually store intermediate results in an external\ndatabase, and build the synchronisation logic into the cloud functions `f` and\n`g`, or use an orchestrator service.\n\n[Read more...](https://teal-book.condense9.com/language/threads.html)\n\n\n### Trivial Pipelines\n\nUse this approach when each individual function may take several minutes (and\nhence, together would break the 5 minute AWS Lambda limit).\n\n```javascript\n/**\n * Compute f(g(h(x))), using a separate lambda invocation for each\n * function call.\n */\nfn pipeline(x) {\n  a = async h(x);\n  b = async g(await a);\n  f(await b);\n}\n```\n\n*Traditional approach:* This is functionally similar to a "chain" of AWS Lambda\nfunctions and SQS queues.\n\n\n### Mapping / reducing\n\nTeal functions are first-class, and can be passed around (closures and anonymous\nfunctions are planned, giving Teal object-oriented capabilities).\n\n```javascript\n/**\n * Compute [f(element) for element in x], using a separate lambda invocation for\n * each application of f.\n */\nfn map(f, x, accumulator) {\n  if nullp(x) {\n    accumulator\n  }\n  else {\n    // The Teal compiler has tail-recursion optimisation\n    map(func, rest(x), append(accumulator, async f(first(x))))\n  }\n}\n```\n\nThis could be used like:\n\n```javascript\nfn add2(x) {\n  x + 2\n}\n\nfn main() {\n  futures = map(add2, [1, 2, 3, 4], []);\n  // ...\n}\n```\n\n[Read more...](https://teal-book.condense9.com/language/functions.html)\n\n\n## Notes about syntax\n\nThe syntax should look familiar, but there are a couple of things to point out.\n\n### No \'return\' statement\n\nEvery expression must return a value, so there is no `return` statement. The\nlast expression in a \'block\' (expressions between `{` and `}`) is returned\nimplicitly.\n\n```javascript\nfn foo() {\n  "something"\n}\n\nfn main() {\n  print(foo())  // -> prints "something"\n}\n```\n\n### Semi-colons are required...\n\n... when there is more than one expression in a block.\n\nThis is ok:\n\n```javascript\nfn main() {\n  print("done")\n}\n```\n\nSo is this:\n\n```javascript\nfn main() {\n  print("one");\n  print("two")\n}\n```\n\nAnd this:\n\n```javascript\nfn main() {\n  print("one");\n  print("two");\n}\n```\n\nBut this is not ok:\n\n```javascript\nfn main() {\n  print("one")  // <- missing semicolon!\n  print("two")\n}\n```\n\n\n### \'print\' returns the value printed\n\nIn this snippet, "Hello Worlds!" is actually printed twice. First in `bar`, then\nin `main`.\n\n```javascript\nfn bar() {\n  print("Hello Worlds!")\n}\n\nfn main() {\n  print(bar())\n}\n```\n\n```shell\n$> teal -q service.tl\nHello Worlds!\nHello Worlds!\n```\n\n### \'if\' is an expression, and returns a value\n\nThink about it like this: An `if` expression represents a choice between\n*values*.\n\n```javascript\nv = if something { true_value } else { false_value };\n\n// if \'something\' is not true, v is set to null\nv = if something { value };\n```\n\n\n## FAQ\n<!-- NOTE: Taken from guide/src/why.md -->\n\n**Why is this not a library/DSL in Python?**\n\nWhen Teal threads wait on a Future, they stop completely. The Lambda function\nsaves the machine state and then terminates. When the Future resolves, the\nresolving thread restarts any waiting threads by invoking new Lambdas to pick up\nexecution.\n\nTo achieve the same thing in Python, the framework would need to dump the entire\nPython VM state to disk, and then reload it at a later point -- this may be\npossible, but would certainly be non-trivial. An alternative approach would be\nto build a langauge on top of Python that looked similar to Python, but felt\n*wrong* because it was really faking things under the hood.\n\n**How is Teal like Go?**\n\nGoroutines are very lightweight, while Teal `async` functions are pretty heavy --\nthey involve creating a new Lambda (or process, when running locally).\n\nTeal\'s concurrency model is similar to Go\'s, but channels are not fully\nimplemented so data can only be sent to/from a thread at call/return points.\n\n**Is this an infrastructure-as-code tool?**\n\nNo, Teal does not do general-purpose infrastructure management. There are\nalready great tools to do that ([Terraform](https://www.terraform.io/),\n[Pulumi](https://www.pulumi.com/), [Serverless\nFramework](https://www.serverless.com/), etc).\n\nInstead, Teal reduces the amount of infrastructure you need. Instead of a\ndistinct Lambda function for every piece of application logic, you only need the\ncore Teal interpreter (purely serverless) infrastructure.\n\nTeal will happily manage that infrastructure for you (through `teal deploy` and\n`teal destroy`), or you can set it up with your in-house custom system.\n\n\n## Current Limitations and Roadmap\n\nTeal is beta quality, which means that it\'s not thoroughly tested or feature\ncomplete. This is a non-exhaustive list.\n\n### Libraries\n\nOnly one Teal program file is supported, but a module/package system is\n[planned](https://github.com/condense9/teal-lang/issues/9).\n\n### Error Handling\n\nThere\'s no error handling - if your function fails, you\'ll have to restart the\nwhole process manually. An exception handling system is\n[planned](https://github.com/condense9/teal-lang/issues/1).\n\n### Typing\n\nFunction inputs and outputs aren\'t typed. This is a limitation, and will be\nfixed soon, probably using\n[ProtoBufs](https://developers.google.com/protocol-buffers/) as the interface\ndefinition language.\n\n### Calling Arbitrary Services\n\nCurrently you can only call Teal or Python functions -- arbitrary microservices\ncan\'t be called. Before Teal v1.0 is released, this will be possible. You will\nbe able to call a long-running third party service (e.g. an AWS ML service) as a\nnormal Teal function and `await` on the result.\n\n\n---\n\n## About\n\nTeal is maintained by [Condense9 Ltd.](https://www.condense9.com/). Get in touch\nwith [ric@condense9.com](ric@condense9.com) for help getting running, or if you\nneed enterprise deployment.\n\nTeal started because we couldn\'t find any data engineering tools that were\nproductive and *felt* like software engineering. As an industry, we\'ve spent\ndecades growing a wealth of computer science knowledge, but building data\npipelines in $IaC, or manually crafting workflow DAGs with $AutomationTool,\n*just isn\'t software*.\n\n## License\n\nApache License (Version 2.0). See [LICENSE](LICENSE) for details.\n\n---\n\n[![forthebadge](https://forthebadge.com/images/badges/gluten-free.svg)](https://forthebadge.com) [![forthebadge](https://forthebadge.com/images/badges/built-with-love.svg)](https://forthebadge.com) [![forthebadge](https://forthebadge.com/images/badges/check-it-out.svg)](https://forthebadge.com)\n\n',
    'author': 'Ric da Silva',
    'author_email': 'ric@condense9.com',
    'maintainer': 'Ric da Silva',
    'maintainer_email': 'ric@condense9.com',
    'url': 'https://www.condense9.com',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
