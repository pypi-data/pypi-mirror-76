from requests import Session
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List
from argparse import ArgumentParser

# Dataclasses generated by https://quicktype.io

__version__ = "1.0"

class jService:
    """The jService API. From the about page of the website [https://jservice.io/]:
    This is in large part a project to learn a bit about screen-scraping and creating an easily consumable set of services for public consumption. I will be offering this free of charge, but on a small Heroku instance until sufficient demand exists. Production use is at your own risk.
    """

    def __init__(self, baseURL : str = "https://jservice.io"):
        """Initialize jService.

        Args:
            baseURL (str, optional): Base URL to send requests to; use if you are making calls to your own instance of jService. Defaults to "https://jservice.io".
        """
        @dataclass
        class Category:
            id: int
            title: str
            created_at: datetime
            updated_at: datetime
            clues_count: int

        @dataclass
        class Clue:
            id: int
            answer: str
            question: str
            value: Optional[int]
            airdate: datetime
            created_at: datetime
            updated_at: datetime
            category_id: int
            game_id: Optional[int]
            invalid_count: Optional[int]
            category: Category

        self.baseURL = baseURL
        self.session = Session()
        self.Clue = Clue
        self.Category = Category

    def clues(self, **kwargs) -> list:
        """Get a list of clues.

        Args:
            value (int, optional): The value of the clue in dollars.
            category (int, optional): The id of the category you want to return.
            min_date (datetime, optional): Earliest date to show, based on original air date.
            max_date (datetime, optional): Latest date to show, based on original air date.
            offset (int, optional): Offsets the returned clues. Useful in pagination.

        Returns:
            list: A list of Clue dataclasses.
        """

        response = self.session.get(f"{self.baseURL}/api/clues", params=kwargs)
        response.raise_for_status()
        array = response.json()
        clues = []
        for clue in array:
            clue["category"] = self.Category(**clue["category"])
            clues.append(self.Clue(**clue))
        return clues

    def random(self, count: int = 1) -> list:
        """Get random clues.

        Args:
            count (int, optional): Amount of clues to return, limited to 100 at a time. Defaults to 1.

        Returns:
            list: A list of Clue dataclasses.
        """
        response = self.session.get(
            f"{self.baseURL}/api/random", params={"count": count}
        )
        response.raise_for_status()
        array = response.json()
        clues = []
        for clue in array:
            clue["category"] = self.Category(**clue["category"])
            clues.append(self.Clue(**clue))
        return clues

    def categories(self, count: int = 1, offset: int = 0) -> list:
        """Get a list of categories.

        Args:
            count (int, optional): Amount of categories to return, limited to 100 at a time. Defaults to 1.
            offset (int, optional): Offsets the starting ID of categories returned. Useful in pagination. Defaults to 0.

        Returns:
            list: A list of Category dataclasses.
        """

        @dataclass
        class Category:
            id: int
            title: str
            clues_count: int

        response = self.session.get(
            f"{self.baseURL}/api/categories", params={"count": count, "offset": offset}
        )
        response.raise_for_status()
        array = response.json()
        cats = []
        for category in array:
            cats.append(Category(**category))
        return cats

    def category(self, id: int):
        """Get a category.

        Args:
            id (int): The ID of the category to return.

        Returns:
            Category: A dataclass containing the cateory ID, title, number of clues, and list of clues for the category.
        """

        @dataclass
        class Clue:
            id: int
            answer: str
            question: str
            value: Optional[int]
            airdate: datetime
            category_id: int
            game_id: Optional[int]
            invalid_count: Optional[int]

        @dataclass
        class Category:
            id: int
            title: str
            clues_count: int
            clues: List[Clue]

        response = self.session.get(f"{self.baseURL}/api/category", params={"id": id})
        response.raise_for_status()
        cat = response.json()

        i = 0
        while i < len(cat["clues"]):
            cat["clues"][i] = Clue(**cat["clues"][i])
            i += 1

        return Category(**cat)

if __name__ == "__main__":
    jeopardy = jService()

    parser = ArgumentParser(
        prog="jServicePy",
        description=f"Play Jeopardy in your terminal! Powered by @sottenad's jService [https://github.com/sottenad/jService] (v{__version__})",
    )
    parser.add_argument(
        "-c",
        "--categories",
        type=int,
        default=0,
        help="Answer questions from a NUMBER of random categories.",
        metavar="NUMBER",
    )
    parser.add_argument(
        "-r",
        "--random",
        help="Answer a NUMBER of random questions",
        type=int,
        default=0,
        metavar="NUMBER",
    )
    parser.add_argument(
        "-v", "--version", action="version", version="%(prog)s version " + __version__,
    )
    args = parser.parse_args()
    score = 0
    if args.random:
        clues = jeopardy.random(count=args.random)
        for clue in clues:
            if clue.question:
                print(f"\u001b[1mCategory\u001b[0m: {clue.category.title}")
                print(f"\u001b[1mQuestion\u001b[0m: {clue.question}")
                print(f"\u001b[1mValue\u001b[0m: ${clue.value}")
                if input(
                    "\u001b[1mWhat/who is\u001b[0m: "
                ).casefold() == clue.answer.casefold().replace("<i>", "").replace(
                    "</i>", ""
                ):
                    score += clue.value
                    print(
                        f"\u001b[32mYou're correct! Your current score is ${score}.\u001b[0m"
                    )
                    print(
                        "\u001b[34m=== === === === === === === === === === === ===\u001b[0m"
                    )
                else:
                    score -= clue.value
                    print(
                        f"\u001b[31mYou're incorrect; the answer is 'What/who is {clue.answer}?' Your current score is ${score}.\u001b[0m"
                    )
                    print(
                        "\u001b[34m=== === === === === === === === === === === ===\u001b[0m"
                    )
        print(f"\u001b[1mYour final score is \u001b[4m${score}\u001b[0m\u001b[1m!\u001b[0m")
        quit()
    if args.categories:
        clues = jeopardy.random(count=args.categories)
        ids = []
        for clue in clues:
            ids.append(clue.category.id)
        categories = []
        for i in ids:
            categories.append(jeopardy.category(i))
        for category in categories:
            print(f"\u001b[1mCategory\u001b[0m: {category.title}")
            print("\u001b[34m=== === === === === === === === === === === ===\u001b[0m")
            i = 0
            while i < 5:
                clue = category.clues[i]
                if clue.question:
                    print(f"\u001b[1mQuestion\u001b[0m: {clue.question}")
                    print(f"\u001b[1mValue\u001b[0m: ${clue.value}")
                    if input(
                        "\u001b[1mWhat/who is\u001b[0m: "
                    ).casefold() == clue.answer.casefold().replace("<i>", "").replace(
                        "</i>", ""
                    ):
                        score += clue.value
                        print(
                            f"\u001b[32mYou're correct! Your current score is ${score}.\u001b[0m"
                        )
                        print(
                            "\u001b[34m=== === === === === === === === === === === ===\u001b[0m"
                        )
                    else:
                        score -= clue.value
                        print(
                            f"\u001b[31mYou're incorrect; the answer is 'What/who is {clue.answer}?' Your current score is ${score}.\u001b[0m"
                        )
                        print(
                            "\u001b[34m=== === === === === === === === === === === ===\u001b[0m"
                        )
                    i += 1
        print(f"\u001b[1mYour final score is \u001b[4m${score}!\u001b[0m")
        quit()
